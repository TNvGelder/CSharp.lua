using System.Text;

namespace RobloxTypeGenerator.Generators;

/// <summary>
/// Generates XML metadata files for CSharp.lua transpilation.
/// Uses string-based generation since output is XML, not C#.
/// </summary>
public class MetadataGenerator : GeneratorBase {
    private readonly List<ApiClass> _classes;
    private readonly SecurityLevel _securityLevel;
    private readonly StringBuilder _sb = new();
    private int _indent = 0;

    // Reference shared skip list from Constants.cs
    private static HashSet<string> SkipClasses => GeneratorConstants.HandWrittenClasses;

    public MetadataGenerator(List<ApiClass> classes, SecurityLevel securityLevel) {
        _classes = classes;
        _securityLevel = securityLevel;
    }

    private void AppendLine(string line = "") {
        if (string.IsNullOrEmpty(line)) {
            _sb.AppendLine();
        } else {
            _sb.Append(new string(' ', _indent * 4));
            _sb.AppendLine(line);
        }
    }

    private void Indent() => _indent++;
    private void Dedent() => _indent = Math.Max(0, _indent - 1);

    public string Generate() {
        AppendLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
        AppendLine("<!-- Auto-generated by RobloxTypeGenerator -->");
        AppendLine("<meta>");
        Indent();
        AppendLine("<assembly>");
        Indent();
        AppendLine("<namespace name=\"Roblox\">");
        Indent();

        // Filter and sort classes
        var filteredClasses = _classes
            .Where(c => !SkipClasses.Contains(c.Name))
            .Where(c => _securityLevel == SecurityLevel.None || ShouldGenerateClass(c, _securityLevel))
            .OrderBy(c => c.Name)
            .ToList();

        foreach (var cls in filteredClasses) {
            GenerateClassMetadata(cls);
        }

        Dedent();
        AppendLine("</namespace>");
        Dedent();
        AppendLine("</assembly>");
        Dedent();
        AppendLine("</meta>");

        return _sb.ToString();
    }

    private void GenerateClassMetadata(ApiClass cls) {
        // Filter members based on security level
        var members = cls.Members
            .Where(m => ShouldGenerateMember(m, _securityLevel))
            .OrderBy(m => m.MemberType)
            .ThenBy(m => m.Name)
            .ToList();

        if (members.Count == 0) {
            return;
        }

        AppendLine($"<class name=\"{EscapeXml(cls.Name)}\">");
        Indent();

        foreach (var member in members) {
            GenerateMemberMetadata(member);
        }

        Dedent();
        AppendLine("</class>");
    }

    private void GenerateMemberMetadata(ApiMember member) {
        switch (member.MemberType) {
            case "Property":
                GeneratePropertyMetadata(member);
                break;
            case "Function":
                GenerateFunctionMetadata(member);
                break;
            case "Event":
                GenerateEventMetadata(member);
                break;
            case "Callback":
                GenerateCallbackMetadata(member);
                break;
        }
    }

    private void GeneratePropertyMetadata(ApiMember member) {
        string name = member.Name;
        string luaAccess = GetLuaPropertyAccess(name);

        AppendLine($"<property name=\"{EscapeXml(name)}\">");
        Indent();

        if (!member.IsWriteOnly) {
            AppendLine($"<get Template=\"{{this}}{EscapeXml(luaAccess)}\" />");
        }
        if (!member.IsReadOnly) {
            AppendLine($"<set Template=\"{{this}}{EscapeXml(luaAccess)} = {{0}}\" />");
        }

        Dedent();
        AppendLine("</property>");
    }

    /// <summary>
    /// Gets the Lua property access syntax for a property name.
    /// Uses bracket notation for names with special characters.
    /// </summary>
    private static string GetLuaPropertyAccess(string name) {
        // Check if name requires bracket notation
        bool needsBrackets = name.Any(c => !char.IsLetterOrDigit(c) && c != '_') ||
                             char.IsDigit(name.FirstOrDefault());

        if (needsBrackets) {
            // Use bracket notation with escaped string
            string escaped = name.Replace("\\", "\\\\").Replace("\"", "\\\"");
            return $"[\"{escaped}\"]";
        } else {
            return "." + name;
        }
    }

    private void GenerateFunctionMetadata(ApiMember member) {
        string name = member.Name;
        int argCount = member.Parameters.Count;

        // Build parameter placeholders
        var paramPlaceholders = new List<string>();
        for (int i = 0; i < argCount; i++) {
            paramPlaceholders.Add($"{{{i}}}");
        }
        string paramsStr = string.Join(", ", paramPlaceholders);

        // Use colon syntax for instance methods
        string template = argCount > 0
            ? $"{{this}}:{name}({paramsStr})"
            : $"{{this}}:{name}()";

        if (argCount > 0) {
            AppendLine($"<method name=\"{EscapeXml(name)}\" ArgCount=\"{argCount}\" Template=\"{EscapeXml(template)}\" />");
        } else {
            AppendLine($"<method name=\"{EscapeXml(name)}\" Template=\"{EscapeXml(template)}\" />");
        }
    }

    private void GenerateEventMetadata(ApiMember member) {
        string name = member.Name;
        string luaAccess = GetLuaPropertyAccess(name);

        // Events are accessed as properties
        AppendLine($"<property name=\"{EscapeXml(name)}\">");
        Indent();
        AppendLine($"<get Template=\"{{this}}{EscapeXml(luaAccess)}\" />");
        Dedent();
        AppendLine("</property>");
    }

    private void GenerateCallbackMetadata(ApiMember member) {
        string name = member.Name;
        string luaAccess = GetLuaPropertyAccess(name);

        // Callbacks are accessed and set like properties
        AppendLine($"<property name=\"{EscapeXml(name)}\">");
        Indent();
        AppendLine($"<get Template=\"{{this}}{EscapeXml(luaAccess)}\" />");
        AppendLine($"<set Template=\"{{this}}{EscapeXml(luaAccess)} = {{0}}\" />");
        Dedent();
        AppendLine("</property>");
    }
}
