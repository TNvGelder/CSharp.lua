using System.Text;

namespace RobloxTypeGenerator.Generators;

/// <summary>
/// Generates XML metadata files for CSharp.lua transpilation.
/// Uses string-based generation since output is XML, not C#.
/// </summary>
public class MetadataGenerator : GeneratorBase {
    private readonly List<ApiClass> _classes;
    private readonly SecurityLevel _securityLevel;
    private readonly PluginGenerationMode _pluginMode;
    private readonly string _namespaceName;
    private readonly HashSet<string> _nonePassClasses;
    private readonly StringBuilder _sb = new();
    private int _indent = 0;

    // Reference shared skip list from Constants.cs
    private static HashSet<string> SkipClasses => GeneratorConstants.HandWrittenClasses;

    public MetadataGenerator(
        List<ApiClass> classes,
        SecurityLevel securityLevel,
        PluginGenerationMode pluginMode = PluginGenerationMode.None,
        string namespaceName = "Roblox",
        HashSet<string>? nonePassClasses = null) {
        _classes = classes;
        _securityLevel = securityLevel;
        _pluginMode = pluginMode;
        _namespaceName = namespaceName;
        _nonePassClasses = nonePassClasses ?? new();
    }

    private void AppendLine(string line = "") {
        if (string.IsNullOrEmpty(line)) {
            _sb.AppendLine();
        } else {
            _sb.Append(new string(' ', _indent * 4));
            _sb.AppendLine(line);
        }
    }

    private void Indent() => _indent++;
    private void Dedent() => _indent = Math.Max(0, _indent - 1);

    public string Generate() {
        AppendLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
        AppendLine("<!-- Auto-generated by RobloxTypeGenerator -->");
        AppendLine("<meta>");
        Indent();
        AppendLine("<assembly>");
        Indent();
        AppendLine($"<namespace name=\"{EscapeXml(_namespaceName)}\">");
        Indent();

        // Filter classes based on mode:
        // - None mode: skip hand-written classes (they have metadata in Roblox.xml)
        // - Plugin mode: include hand-written classes so we generate metadata for plugin members
        var filteredClasses = _pluginMode == PluginGenerationMode.None
            ? _classes.Where(c => !SkipClasses.Contains(c.Name)).OrderBy(c => c.Name).ToList()
            : _classes.Where(c => c.Name != "<<<ROOT>>>").OrderBy(c => c.Name).ToList();

        foreach (var cls in filteredClasses) {
            bool hasNoneMembers = cls.Members.Any(m => ShouldGenerateMember(m, SecurityLevel.None));
            bool hasPluginMembers = cls.Members.Any(m => ShouldGenerateMember(m, SecurityLevel.PluginSecurity));

            if (_pluginMode == PluginGenerationMode.None) {
                // Normal None-security pass
                if (hasNoneMembers) {
                    GenerateClassMetadata(cls, cls.Name);
                }
            } else {
                // Plugin pass
                if (hasPluginMembers) {
                    // Check if base class exists (generated in None pass, or hand-written)
                    bool baseClassExists = hasNoneMembers || _nonePassClasses.Contains(cls.Name) || SkipClasses.Contains(cls.Name);

                    // Extension interfaces get Plugin suffix, plugin-only classes use regular name
                    string className = baseClassExists ? cls.Name + "Plugin" : cls.Name;
                    GenerateClassMetadata(cls, className);
                }
            }
        }

        Dedent();
        AppendLine("</namespace>");
        Dedent();
        AppendLine("</assembly>");
        Dedent();
        AppendLine("</meta>");

        return _sb.ToString();
    }

    private void GenerateClassMetadata(ApiClass cls, string className) {
        // Filter members based on security level
        var members = cls.Members
            .Where(m => ShouldGenerateMember(m, _securityLevel))
            .OrderBy(m => m.MemberType)
            .ThenBy(m => m.Name)
            .ToList();

        if (members.Count == 0) {
            return;
        }

        AppendLine($"<class name=\"{EscapeXml(className)}\">");
        Indent();

        foreach (var member in members) {
            GenerateMemberMetadata(member);
        }

        Dedent();
        AppendLine("</class>");
    }

    private void GenerateMemberMetadata(ApiMember member) {
        switch (member.MemberType) {
            case "Property":
                GeneratePropertyMetadata(member);
                break;
            case "Function":
                GenerateFunctionMetadata(member);
                break;
            case "Event":
                GenerateEventMetadata(member);
                break;
            case "Callback":
                GenerateCallbackMetadata(member);
                break;
        }
    }

    private void GeneratePropertyMetadata(ApiMember member) {
        string name = member.Name;
        string luaAccess = GetLuaPropertyAccess(name);

        // Check accessor security - setter may require higher security than getter
        string readSecurity = member.GetReadSecurity();
        string writeSecurity = member.GetWriteSecurity();

        bool canRead = !member.IsWriteOnly && CanAccessAtSecurityLevel(readSecurity, _securityLevel);
        bool canWrite = !member.IsReadOnly && CanAccessAtSecurityLevel(writeSecurity, _securityLevel);

        // Skip if neither accessor is available at this security level
        if (!canRead && !canWrite) {
            return;
        }

        // Use IsField="true" pattern for writable properties (no <set> tag needed)
        if (canWrite) {
            AppendLine($"<property name=\"{EscapeXml(name)}\" IsField=\"true\">");
        } else {
            AppendLine($"<property name=\"{EscapeXml(name)}\">");
        }
        Indent();

        // Only emit <get> - never emit <set> when using IsField pattern
        if (canRead) {
            AppendLine($"<get Template=\"{{this}}{EscapeXml(luaAccess)}\" />");
        }

        Dedent();
        AppendLine("</property>");
    }

    /// <summary>
    /// Checks if a member is accessible at the given security level.
    /// </summary>
    private static bool CanAccessAtSecurityLevel(string memberSecurity, SecurityLevel currentLevel) {
        return currentLevel switch {
            SecurityLevel.None => memberSecurity == "None",
            SecurityLevel.PluginSecurity => memberSecurity == "None" || memberSecurity == "PluginSecurity",
            _ => false
        };
    }

    /// <summary>
    /// Gets the Lua property access syntax for a property name.
    /// Uses bracket notation for names with special characters.
    /// </summary>
    private static string GetLuaPropertyAccess(string name) {
        // Check if name requires bracket notation
        bool needsBrackets = name.Any(c => !char.IsLetterOrDigit(c) && c != '_') ||
                             char.IsDigit(name.FirstOrDefault());

        if (needsBrackets) {
            // Use bracket notation with escaped string
            string escaped = name.Replace("\\", "\\\\").Replace("\"", "\\\"");
            return $"[\"{escaped}\"]";
        } else {
            return "." + name;
        }
    }

    private void GenerateFunctionMetadata(ApiMember member) {
        string name = member.Name;
        int argCount = member.Parameters.Count;

        // Build parameter placeholders
        var paramPlaceholders = new List<string>();
        for (int i = 0; i < argCount; i++) {
            paramPlaceholders.Add($"{{{i}}}");
        }
        string paramsStr = string.Join(", ", paramPlaceholders);

        // Use colon syntax for instance methods
        string template = argCount > 0
            ? $"{{this}}:{name}({paramsStr})"
            : $"{{this}}:{name}()";

        if (argCount > 0) {
            AppendLine($"<method name=\"{EscapeXml(name)}\" ArgCount=\"{argCount}\" Template=\"{EscapeXml(template)}\" />");
        } else {
            AppendLine($"<method name=\"{EscapeXml(name)}\" Template=\"{EscapeXml(template)}\" />");
        }
    }

    private void GenerateEventMetadata(ApiMember member) {
        string name = member.Name;
        string luaAccess = GetLuaPropertyAccess(name);

        // Events are accessed as properties
        AppendLine($"<property name=\"{EscapeXml(name)}\">");
        Indent();
        AppendLine($"<get Template=\"{{this}}{EscapeXml(luaAccess)}\" />");
        Dedent();
        AppendLine("</property>");
    }

    private void GenerateCallbackMetadata(ApiMember member) {
        string name = member.Name;
        string luaAccess = GetLuaPropertyAccess(name);

        // Callbacks are accessed and set like properties
        AppendLine($"<property name=\"{EscapeXml(name)}\">");
        Indent();
        AppendLine($"<get Template=\"{{this}}{EscapeXml(luaAccess)}\" />");
        AppendLine($"<set Template=\"{{this}}{EscapeXml(luaAccess)} = {{0}}\" />");
        Dedent();
        AppendLine("</property>");
    }
}
