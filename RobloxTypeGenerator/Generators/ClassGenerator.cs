using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace RobloxTypeGenerator.Generators;

public class ClassGenerator : GeneratorBase {
    private readonly List<ApiClass> _classes;
    private readonly Dictionary<string, ApiDocEntry> _docs;
    private readonly SecurityLevel _securityLevel;
    private readonly HashSet<string> _classNames;
    private readonly HashSet<string> _additionalSkipClasses;
    private readonly HashSet<string> _generatedClasses = new();

    // Reference shared skip list from Constants.cs
    private static HashSet<string> SkipClasses => GeneratorConstants.HandWrittenClasses;

    public ClassGenerator(
        List<ApiClass> classes,
        Dictionary<string, ApiDocEntry> docs,
        SecurityLevel securityLevel,
        HashSet<string>? additionalSkipClasses = null) {

        _classes = classes;
        _docs = docs;
        _securityLevel = securityLevel;
        _classNames = classes.Select(c => c.Name).ToHashSet();
        _additionalSkipClasses = additionalSkipClasses ?? new();
    }

    /// <summary>
    /// Gets the set of class names that were generated.
    /// </summary>
    public HashSet<string> GeneratedClasses => _generatedClasses;

    public CompilationUnitSyntax Generate() {
        var members = new List<MemberDeclarationSyntax>();

        // Filter and sort classes
        var filteredClasses = _classes
            .Where(c => !SkipClasses.Contains(c.Name))
            .Where(c => !_additionalSkipClasses.Contains(c.Name))
            .Where(c => _securityLevel == SecurityLevel.None || ShouldGenerateClass(c, _securityLevel))
            .OrderBy(c => c.Name)
            .ToList();

        foreach (var cls in filteredClasses) {
            var interfaceDecl = GenerateClass(cls);
            if (interfaceDecl != null) {
                members.Add(interfaceDecl);
                _generatedClasses.Add(cls.Name);
            }
        }

        // Create namespace
        var namespaceDecl = FileScopedNamespaceDeclaration(IdentifierName("Roblox"))
            .WithMembers(List(members));

        // Create compilation unit with header
        var compilationUnit = CompilationUnit()
            .WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceDecl))
            .WithLeadingTrivia(CreateFileHeader())
            .NormalizeWhitespace();

        return compilationUnit;
    }

    private static SyntaxTriviaList CreateFileHeader() {
        return TriviaList(
            Comment("// <auto-generated>"),
            CarriageReturnLineFeed,
            Comment("// This file was generated by RobloxTypeGenerator."),
            CarriageReturnLineFeed,
            Comment("// Do not edit this file manually."),
            CarriageReturnLineFeed,
            Comment("// </auto-generated>"),
            CarriageReturnLineFeed,
            CarriageReturnLineFeed,
            Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)),
            CarriageReturnLineFeed,
            Trivia(PragmaWarningDirectiveTrivia(
                Token(SyntaxKind.DisableKeyword),
                SingletonSeparatedList<ExpressionSyntax>(
                    IdentifierName("CS0108")),
                true)),
            CarriageReturnLineFeed,
            CarriageReturnLineFeed
        );
    }

    private InterfaceDeclarationSyntax? GenerateClass(ApiClass cls) {
        // Filter members based on security level
        var filteredMembers = cls.Members
            .Where(m => ShouldGenerateMember(m, _securityLevel))
            .OrderBy(m => m.MemberType)
            .ThenBy(m => m.Name)
            .ToList();

        // Generate interface members
        var members = new List<MemberDeclarationSyntax>();
        foreach (var member in filteredMembers) {
            var memberSyntax = GenerateMember(cls.Name, member);
            if (memberSyntax != null) {
                members.Add(memberSyntax);
            }
        }

        // Create interface declaration
        string safeName = MakeSafeIdentifierString(cls.Name);
        var interfaceDecl = InterfaceDeclaration(safeName)
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.PartialKeyword)));

        // Add base type
        var baseType = GetBaseType(cls);
        if (baseType != null) {
            interfaceDecl = interfaceDecl.WithBaseList(
                BaseList(SingletonSeparatedList<BaseTypeSyntax>(
                    SimpleBaseType(IdentifierName(baseType)))));
        }

        // Add members
        interfaceDecl = interfaceDecl.WithMembers(List(members));

        // Add documentation and attributes
        var leadingTrivia = GetClassDocComment(cls);

        // Add Obsolete attribute if deprecated
        if (cls.Tags.Contains("Deprecated")) {
            interfaceDecl = interfaceDecl.WithAttributeLists(
                SingletonList(ObsoleteAttribute("This class is deprecated.")));
        }

        interfaceDecl = interfaceDecl.WithLeadingTrivia(leadingTrivia);

        return interfaceDecl;
    }

    private string? GetBaseType(ApiClass cls) {
        if (!string.IsNullOrEmpty(cls.Superclass) &&
            cls.Superclass != "<<<ROOT>>>" &&
            _classNames.Contains(cls.Superclass)) {
            return MakeSafeIdentifierString(cls.Superclass);
        } else if (cls.Name != "Instance") {
            return "Instance";
        }
        return null;
    }

    private SyntaxTriviaList GetClassDocComment(ApiClass cls) {
        string docKey = $"@roblox/globaltype/{cls.Name}";
        _docs.TryGetValue(docKey, out var doc);

        string summary = doc != null && !string.IsNullOrEmpty(doc.Documentation)
            ? doc.Documentation
            : $"Represents the {cls.Name} class.";

        return CreateDocComment(summary);
    }

    private MemberDeclarationSyntax? GenerateMember(string className, ApiMember member) {
        return member.MemberType switch {
            "Property" => GenerateProperty(className, member),
            "Function" => GenerateFunction(className, member),
            "Event" => GenerateEvent(className, member),
            "Callback" => GenerateCallback(className, member),
            _ => null
        };
    }

    private PropertyDeclarationSyntax GenerateProperty(string className, ApiMember member) {
        string typeName = MapType(member.ValueType);

        // Make class-typed properties nullable (like RobloxTS does)
        // This prevents null reference issues at runtime since these can return nil
        if (member.ValueType?.Category == "Class" && !typeName.EndsWith("?")) {
            typeName += "?";
        }

        var type = ParseTypeString(typeName);
        string safeName = MakeSafeIdentifierString(member.Name);

        // Create accessors based on read/write permissions
        var accessors = new List<AccessorDeclarationSyntax>();
        if (!member.IsWriteOnly) {
            accessors.Add(AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
        }
        if (!member.IsReadOnly) {
            accessors.Add(AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
        }

        var property = PropertyDeclaration(type, Identifier(safeName))
            .WithAccessorList(AccessorList(List(accessors)));

        // Add documentation
        var docComment = GetPropertyDocComment(className, member);
        property = property.WithLeadingTrivia(docComment);

        // Add Obsolete attribute if deprecated
        if (member.IsDeprecated) {
            property = property.WithAttributeLists(
                SingletonList(ObsoleteAttribute("This property is deprecated.")));
        }

        return property;
    }

    private MethodDeclarationSyntax GenerateFunction(string className, ApiMember member) {
        string returnTypeName = MapType(member.ReturnType);
        var returnType = ParseTypeString(returnTypeName);
        string safeName = MakeSafeIdentifierString(member.Name);

        // Create parameters
        var parameters = member.Parameters
            .Select(p => Parameter(SafeIdentifier(p.Name))
                .WithType(ParseTypeString(MapType(p.Type))))
            .ToList();

        var method = MethodDeclaration(returnType, Identifier(safeName))
            .WithParameterList(ParameterList(SeparatedList(parameters)))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

        // Add documentation
        var docComment = GetFunctionDocComment(className, member);
        method = method.WithLeadingTrivia(docComment);

        // Add Obsolete attribute if deprecated
        if (member.IsDeprecated) {
            method = method.WithAttributeLists(
                SingletonList(ObsoleteAttribute("This method is deprecated.")));
        }

        return method;
    }

    private PropertyDeclarationSyntax GenerateEvent(string className, ApiMember member) {
        string signalType = BuildSignalType(member.Parameters);
        var type = ParseTypeString(signalType);
        string safeName = MakeSafeIdentifierString(member.Name);

        var property = PropertyDeclaration(type, Identifier(safeName))
            .WithAccessorList(AccessorList(SingletonList(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))));

        // Add documentation
        var docComment = GetEventDocComment(className, member);
        property = property.WithLeadingTrivia(docComment);

        // Add Obsolete attribute if deprecated
        if (member.IsDeprecated) {
            property = property.WithAttributeLists(
                SingletonList(ObsoleteAttribute("This event is deprecated.")));
        }

        return property;
    }

    private PropertyDeclarationSyntax GenerateCallback(string className, ApiMember member) {
        string delegateType = BuildDelegateType(member.Parameters, member.ReturnType);
        var type = ParseTypeString(delegateType);
        string safeName = MakeSafeIdentifierString(member.Name);

        var property = PropertyDeclaration(type, Identifier(safeName))
            .WithAccessorList(AccessorList(List(new[] {
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
            })));

        // Add documentation
        var docComment = GetCallbackDocComment(className, member);
        property = property.WithLeadingTrivia(docComment);

        // Add Obsolete attribute if deprecated
        if (member.IsDeprecated) {
            property = property.WithAttributeLists(
                SingletonList(ObsoleteAttribute("This callback is deprecated.")));
        }

        return property;
    }

    private SyntaxTriviaList GetPropertyDocComment(string className, ApiMember member) {
        string docKey = $"@roblox/globaltype/{className}.{member.Name}";
        _docs.TryGetValue(docKey, out var doc);

        string summary = doc != null && !string.IsNullOrEmpty(doc.Documentation)
            ? doc.Documentation
            : $"Gets or sets the {member.Name} property.";

        string? remarks = null;
        if (!string.IsNullOrEmpty(member.ThreadSafety)) {
            remarks = GetThreadSafetyDoc(member.ThreadSafety);
        }

        return CreateDocComment(summary, remarks);
    }

    private SyntaxTriviaList GetFunctionDocComment(string className, ApiMember member) {
        string docKey = $"@roblox/globaltype/{className}.{member.Name}";
        _docs.TryGetValue(docKey, out var doc);

        string summary = doc != null && !string.IsNullOrEmpty(doc.Documentation)
            ? doc.Documentation
            : $"{member.Name} method.";

        // Build parameters documentation
        var paramDocs = new List<(string name, string doc)>();
        if (doc?.Params != null) {
            foreach (var param in doc.Params) {
                paramDocs.Add((param.Name, param.Documentation));
            }
        }

        // Returns documentation
        string? returns = null;
        if (doc?.Returns != null && doc.Returns.Count > 0) {
            returns = doc.Returns[0].Documentation;
        }

        // Remarks (thread safety + yield)
        string? remarks = null;
        var remarksList = new List<string>();
        if (!string.IsNullOrEmpty(member.ThreadSafety)) {
            var threadDoc = GetThreadSafetyDoc(member.ThreadSafety);
            if (!string.IsNullOrEmpty(threadDoc)) {
                remarksList.Add(threadDoc);
            }
        }
        if (member.CanYield) {
            remarksList.Add("This method can yield.");
        }
        if (remarksList.Count > 0) {
            remarks = string.Join(" ", remarksList);
        }

        return CreateMethodDocComment(summary, paramDocs.Count > 0 ? paramDocs : null, returns, remarks);
    }

    private SyntaxTriviaList GetEventDocComment(string className, ApiMember member) {
        string docKey = $"@roblox/globaltype/{className}.{member.Name}";
        _docs.TryGetValue(docKey, out var doc);

        string summary = doc != null && !string.IsNullOrEmpty(doc.Documentation)
            ? doc.Documentation
            : $"The {member.Name} event.";

        return CreateDocComment(summary);
    }

    private SyntaxTriviaList GetCallbackDocComment(string className, ApiMember member) {
        string docKey = $"@roblox/globaltype/{className}.{member.Name}";
        _docs.TryGetValue(docKey, out var doc);

        string summary = doc != null && !string.IsNullOrEmpty(doc.Documentation)
            ? doc.Documentation
            : $"The {member.Name} callback.";

        return CreateDocComment(summary);
    }

    private static string BuildSignalType(List<ApiParameter> parameters) {
        if (parameters.Count == 0) {
            return "ScriptSignal";
        }

        var types = parameters.Select(p => MapType(p.Type)).ToList();
        return $"ScriptSignal<{string.Join(", ", types)}>";
    }

    private static string BuildDelegateType(List<ApiParameter> parameters, ApiValueType? returnType) {
        string ret = MapType(returnType);
        if (parameters.Count == 0) {
            return ret == "void" ? "Action" : $"Func<{ret}>";
        }

        var types = parameters.Select(p => MapType(p.Type)).ToList();
        if (ret == "void") {
            return $"Action<{string.Join(", ", types)}>";
        }
        types.Add(ret);
        return $"Func<{string.Join(", ", types)}>";
    }
}
