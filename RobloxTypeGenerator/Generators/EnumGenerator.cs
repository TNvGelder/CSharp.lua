using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace RobloxTypeGenerator.Generators;

public class EnumGenerator : GeneratorBase {
    private readonly List<ApiEnum> _enums;
    private readonly Dictionary<string, ApiDocEntry> _docs;

    // Enums that conflict with hand-written type names or have problematic items
    private static readonly HashSet<string> SkipEnums = new() {
        "Font",             // Conflicts with Font data type
        "Platform",         // Conflicts with Platform type
        "Status",           // Conflicts with Status type
        "CompletionItemKind", // Has "Value" item that conflicts with EnumItem.Value
        "LexemeType",       // Has "Name" item that conflicts with EnumItem.Name
        "SortOrder"         // Has "Name" item that conflicts with EnumItem.Name
    };

    public EnumGenerator(List<ApiEnum> enums, Dictionary<string, ApiDocEntry> docs) {
        _enums = enums;
        _docs = docs;
    }

    public CompilationUnitSyntax Generate() {
        var members = new List<MemberDeclarationSyntax>();

        // Add EnumItem base class
        members.Add(CreateEnumItemBaseClass());

        // Generate each enum at top level
        // Note: Roblox uses Enum.Material in Lua, but C# cannot use "Enum" as a class name
        // (conflicts with System.Enum). The transpiler handles mapping C# enum access
        // to Lua's Enum.{EnumName} pattern in LuaSyntaxNodeTransform.cs.
        var sortedEnums = _enums
            .Where(e => !SkipEnums.Contains(e.Name))
            .OrderBy(e => e.Name)
            .ToList();

        foreach (var enumDef in sortedEnums) {
            members.Add(GenerateEnum(enumDef));
        }

        // Create namespace
        var namespaceDecl = FileScopedNamespaceDeclaration(IdentifierName("Roblox"))
            .WithMembers(List(members));

        // Create compilation unit
        var compilationUnit = CompilationUnit()
            .WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceDecl))
            .WithLeadingTrivia(CreateFileHeader())
            .NormalizeWhitespace();

        return compilationUnit;
    }

    private static SyntaxTriviaList CreateFileHeader() {
        return TriviaList(
            Comment("// <auto-generated>"),
            CarriageReturnLineFeed,
            Comment("// This file was generated by RobloxTypeGenerator."),
            CarriageReturnLineFeed,
            Comment("// Do not edit this file manually."),
            CarriageReturnLineFeed,
            Comment("// </auto-generated>"),
            CarriageReturnLineFeed,
            CarriageReturnLineFeed,
            Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)),
            CarriageReturnLineFeed,
            CarriageReturnLineFeed
        );
    }

    private static ClassDeclarationSyntax CreateEnumItemBaseClass() {
        var nameProperty = PropertyDeclaration(
                PredefinedType(Token(SyntaxKind.StringKeyword)),
                Identifier("Name"))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.AbstractKeyword)))
            .WithAccessorList(AccessorList(SingletonList(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))))
            .WithLeadingTrivia(CreateDocComment("The name of the enum item."));

        var valueProperty = PropertyDeclaration(
                PredefinedType(Token(SyntaxKind.IntKeyword)),
                Identifier("Value"))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.AbstractKeyword)))
            .WithAccessorList(AccessorList(SingletonList(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))))
            .WithLeadingTrivia(CreateDocComment("The numeric value of the enum item."));

        return ClassDeclaration("EnumItem")
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.AbstractKeyword)))
            .WithMembers(List<MemberDeclarationSyntax>(new[] { nameProperty, valueProperty }))
            .WithLeadingTrivia(CreateDocComment("Base class for all Roblox enum items."));
    }

    private ClassDeclarationSyntax GenerateEnum(ApiEnum enumDef) {
        var members = new List<MemberDeclarationSyntax>();

        // Add abstract override properties for Name and Value
        var nameProperty = PropertyDeclaration(
                PredefinedType(Token(SyntaxKind.StringKeyword)),
                Identifier("Name"))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.OverrideKeyword),
                Token(SyntaxKind.AbstractKeyword)))
            .WithAccessorList(AccessorList(SingletonList(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))))
            .WithLeadingTrivia(CreateInheritDocComment());

        var valueProperty = PropertyDeclaration(
                PredefinedType(Token(SyntaxKind.IntKeyword)),
                Identifier("Value"))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.OverrideKeyword),
                Token(SyntaxKind.AbstractKeyword)))
            .WithAccessorList(AccessorList(SingletonList(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))))
            .WithLeadingTrivia(CreateInheritDocComment());

        members.Add(nameProperty);
        members.Add(valueProperty);

        // Generate static properties for each enum item
        foreach (var item in enumDef.Items.OrderBy(i => i.Value)) {
            members.Add(GenerateEnumItem(enumDef.Name, item));
        }

        // Add GetEnumItems method
        members.Add(GenerateGetEnumItemsMethod(enumDef.Name));

        // Create the enum class
        string safeName = MakeSafeIdentifierString(enumDef.Name);
        var classDecl = ClassDeclaration(safeName)
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.AbstractKeyword)))
            .WithBaseList(BaseList(SingletonSeparatedList<BaseTypeSyntax>(
                SimpleBaseType(IdentifierName("EnumItem")))))
            .WithMembers(List(members))
            .WithLeadingTrivia(GetEnumDocComment(enumDef));

        return classDecl;
    }

    private PropertyDeclarationSyntax GenerateEnumItem(string enumName, ApiEnumItem item) {
        string safeName = MakeSafeIdentifierString(item.Name);
        string enumSafeName = MakeSafeIdentifierString(enumName);

        // Determine if we need 'new' keyword for hiding
        var modifiers = new List<SyntaxToken> {
            Token(SyntaxKind.PublicKeyword),
            Token(SyntaxKind.StaticKeyword)
        };

        if (item.Name == "Name" || item.Name == "Value") {
            modifiers.Insert(1, Token(SyntaxKind.NewKeyword));
        }

        modifiers.Add(Token(SyntaxKind.ExternKeyword));

        var property = PropertyDeclaration(
                IdentifierName(enumSafeName),
                Identifier(safeName))
            .WithModifiers(TokenList(modifiers))
            .WithAccessorList(AccessorList(SingletonList(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))))
            .WithLeadingTrivia(GetEnumItemDocComment(enumName, item));

        return property;
    }

    private MethodDeclarationSyntax GenerateGetEnumItemsMethod(string enumName) {
        string safeName = MakeSafeIdentifierString(enumName);

        return MethodDeclaration(
                ArrayType(IdentifierName(safeName))
                    .WithRankSpecifiers(SingletonList(
                        ArrayRankSpecifier(SingletonSeparatedList<ExpressionSyntax>(
                            OmittedArraySizeExpression())))),
                Identifier("GetEnumItems"))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.StaticKeyword),
                Token(SyntaxKind.ExternKeyword)))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
            .WithLeadingTrivia(CreateDocComment("Returns all items in this enum."));
    }

    private SyntaxTriviaList GetEnumDocComment(ApiEnum enumDef) {
        string docKey = $"@roblox/enum/{enumDef.Name}";
        _docs.TryGetValue(docKey, out var doc);

        string summary = doc != null && !string.IsNullOrEmpty(doc.Documentation)
            ? doc.Documentation
            : $"Represents the {enumDef.Name} enum.";

        return CreateDocComment(summary);
    }

    private SyntaxTriviaList GetEnumItemDocComment(string enumName, ApiEnumItem item) {
        string docKey = $"@roblox/enum/{enumName}.{item.Name}";
        _docs.TryGetValue(docKey, out var doc);

        string summary = doc != null && !string.IsNullOrEmpty(doc.Documentation)
            ? doc.Documentation
            : $"The {item.Name} enum item. Value = {item.Value}.";

        return CreateDocComment(summary);
    }

    private static SyntaxTriviaList CreateInheritDocComment() {
        return TriviaList(
            Comment("/// <inheritdoc/>"),
            CarriageReturnLineFeed);
    }
}
