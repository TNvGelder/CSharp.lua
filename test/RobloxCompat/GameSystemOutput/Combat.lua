-- Generated by CSharp.lua Compiler
local System = _G.MyGame.System
local GameSystem
System.import(function (out)
  GameSystem = out.GameSystem
end)
System.namespace("GameSystem", function (namespace)
  namespace.enum("DamageType", function ()
    local __ctor__
    __ctor__ = function (this)
      System.base(this).__ctor__(this)
    end
    return {
      Physical = 0,
      Fire = 1,
      Ice = 2,
      Lightning = 3,
      Poison = 4,
      __ctor__ = __ctor__
    }
  end)

  namespace.class("DamageResult", function (namespace)
    local ToString
    ToString = function (this)
      if this.IsDodged then
        return "DODGED!"
      end
      local crit = this.IsCritical and " (CRIT!)" or ""
      return System.toString(this.FinalDamage, "F1") .. " " .. System.EnumToString(this.Type, GameSystem.DamageType) .. " damage" .. crit
    end
    return {
      RawDamage = 0,
      FinalDamage = 0,
      IsCritical = false,
      IsDodged = false,
      Type = 0,
      ToString = ToString
    }
  end)

  namespace.class("CombatComponent", function (namespace)
    local getName, CalculateDamage, Attack, TakeDamage, Update, class, __ctor__
    __ctor__ = function (this, owner)
      this._random = System.Random()
      this._owner = owner
    end
    getName = function (this)
      return "Combat"
    end
    CalculateDamage = function (this, target, baseDamage, type)
      local default = GameSystem.DamageResult()
      default.RawDamage = baseDamage
      default.Type = type
      local result = default

      local attackerStats = this._owner:GetComponent(GameSystem.StatsComponent)
      local defenderStats = target:GetComponent(GameSystem.StatsComponent)

      if attackerStats == nil or defenderStats == nil then
        result.FinalDamage = baseDamage
        return result
      end

      -- Check for dodge
      local dodgeChance = defenderStats:GetStatValue("DodgeChance")
      if this._random:NextDouble() * 100 < dodgeChance then
        result.IsDodged = true
        result.FinalDamage = 0
        return result
      end

      -- Check for crit
      local critChance = attackerStats:GetStatValue("CritChance")
      local critMultiplier = attackerStats:GetStatValue("CritMultiplier")
      if critMultiplier == 0 then
        critMultiplier = 150
      end
      -- Default 150%

      if this._random:NextDouble() * 100 < critChance then
        result.IsCritical = true
        baseDamage = baseDamage * ((critMultiplier / 100))
      end

      -- Apply attack power
      local attackPower = attackerStats:GetStatValue("AttackPower")
      local damage = baseDamage + attackPower

      -- Apply defense
      local defense = defenderStats:GetStatValue("Defense")
      local damageReduction = defense / (defense + 100)
      -- Diminishing returns formula
      damage = damage * (1 - damageReduction)

      -- Apply resistance for elemental damage
      if type ~= 0 --[[DamageType.Physical]] then
        local resistStat = System.EnumToString(type, GameSystem.DamageType) .. "Resist"
        local resistance = defenderStats:GetStatValue(resistStat)
        damage = damage * (1 - resistance / 100)
      end

      result.FinalDamage = math.max(1, damage)
      -- Minimum 1 damage
      return result
    end
    Attack = function (this, target, baseDamage, type)
      local result = CalculateDamage(this, target, baseDamage, type)

      local default = this.OnDamageDealt
      if default ~= nil then
        default(target, result)
      end

      local targetCombat = target:GetComponent(class)
      local default = targetCombat
      if default ~= nil then
        TakeDamage(default, this._owner, result)
      end
    end
    TakeDamage = function (this, attacker, result)
      if result.IsDodged then
        return
      end

      local default = this.OnDamageTaken
      if default ~= nil then
        default(attacker, result)
      end

      local stats = this._owner:GetComponent(GameSystem.StatsComponent)
      if stats ~= nil then
        local healthStat = stats:GetStat("Health")
        if healthStat ~= nil then
          healthStat.BaseValue = healthStat.BaseValue - result.FinalDamage
          if healthStat:getValue() <= 0 then
            this._owner.IsActive = false
            local default = this.OnDeath
            if default ~= nil then
              default()
            end
          end
        end
      end
    end
    Update = function (this, deltaTime)
      -- Combat component doesn't need regular updates
    end
    class = {
      base = function (out)
        return {
          out.GameSystem.IComponent
        }
      end,
      getName = getName,
      CalculateDamage = CalculateDamage,
      Attack = Attack,
      TakeDamage = TakeDamage,
      Update = Update,
      __ctor__ = __ctor__
    }
    return class
  end)
end)

return true
